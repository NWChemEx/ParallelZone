

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Understanding Runtime Initialization/Finalization &mdash; parallelzone  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Reflection Design" href="design/reflection.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            parallelzone
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../background/index.html">ParallelZone Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installing ParallelZone</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">ParallelZone User Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Developer Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="design/index.html">Design Documentation</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Understanding Runtime Initialization/Finalization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#raii-and-mpi">RAII and MPI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#traditional-solution">Traditional Solution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#raii-interacting-with-traditional-solution">RAII Interacting With Traditional Solution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#raii-plus-encapsulation">RAII Plus Encapsulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">parallelzone</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Developer Documentation</a></li>
      <li class="breadcrumb-item active">Understanding Runtime Initialization/Finalization</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/developer/initialize_finalize.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="understanding-runtime-initialization-finalization">
<span id="id1"></span><h1>Understanding Runtime Initialization/Finalization<a class="headerlink" href="#understanding-runtime-initialization-finalization" title="Link to this heading"></a></h1>
<p><a class="reference internal" href="../background/abbreviations.html#mpi"><span class="std std-ref">MPI</span></a> requires users to call <code class="docutils literal notranslate"><span class="pre">MPI_Init</span></code>  to start MPI and
<code class="docutils literal notranslate"><span class="pre">MPI_Finalize</span></code> to end it. MPI requires that each of these functions be called
only once, regardless of how many code units actually use MPI, i.e., managing
the lifetime of resources such as MPI processes and adhering to <a class="reference internal" href="../background/abbreviations.html#raii"><span class="std std-ref">RAII</span></a> can
be tricky. This page works through some scenarios to help the reader become
better acquainted with the complexities.</p>
<section id="raii-and-mpi">
<h2>RAII and MPI<a class="headerlink" href="#raii-and-mpi" title="Link to this heading"></a></h2>
<p>ParallelZone opts to manage MPI through RAII. To do this we associate the
lifetime of MPI with the lifetime of a <code class="docutils literal notranslate"><span class="pre">Runtime</span></code> object. When a <code class="docutils literal notranslate"><span class="pre">Runtime</span></code>
object is created it is either initialized with an existing MPI communicator or
it initializes MPI and then uses the MPI communicator resulting from
initialization. Each <code class="docutils literal notranslate"><span class="pre">Runtime</span></code> object internally tracks whether it initialized
MPI or not. When a <code class="docutils literal notranslate"><span class="pre">Runtime</span></code> object is destructed it will only call
<code class="docutils literal notranslate"><span class="pre">MPI_Finalize</span></code> if <code class="docutils literal notranslate"><span class="pre">*this</span></code> initialized MPI.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>At present there is no user-accessible <code class="docutils literal notranslate"><span class="pre">Runtime</span></code> object, rather users
interact with an implicit <code class="docutils literal notranslate"><span class="pre">Runtime</span></code> through <code class="docutils literal notranslate"><span class="pre">RuntimeView</span></code> objects. When
all <code class="docutils literal notranslate"><span class="pre">RuntimeView</span></code> objects go out of scope the implicit <code class="docutils literal notranslate"><span class="pre">Runtime</span></code> object
is destructed. This decision stems from not wanting accidental/implicit
copies to inadvertently shut down MPI.</p>
</div>
</section>
<section id="traditional-solution">
<span id="id2"></span><h2>Traditional Solution<a class="headerlink" href="#traditional-solution" title="Link to this heading"></a></h2>
<p>Many existing libraries deal with the MPI problem in one of two ways:</p>
<ol class="arabic simple">
<li><p>Assume the user will manage MPI. Thus the library requires the user to
provide an already initialized MPI communicator.</p></li>
<li><p>Define functions like <code class="docutils literal notranslate"><span class="pre">initialize</span></code> / <code class="docutils literal notranslate"><span class="pre">finalize</span></code> which wrap MPI’s
<code class="docutils literal notranslate"><span class="pre">MPI_Init</span></code> / <code class="docutils literal notranslate"><span class="pre">MPI_Finalize</span></code> functions respectively.</p></li>
</ol>
<p>From the perspective of PZ Scenario 1 is the easiest to deal with because it
means PZ is free to manage the lifetime of MPI however it wants, so long as MPI
is finalized after the library is done with it. Scenario 1 works well with our
RAII solution “out of the box” and is not considered further.</p>
<p>Scenario 2 is much harder because we know the library’s <code class="docutils literal notranslate"><span class="pre">initialize</span></code> and
<code class="docutils literal notranslate"><span class="pre">finalize</span></code> functions will contain MPI functions. This is because they will
minimally contain <code class="docutils literal notranslate"><span class="pre">MPI_Init</span></code> and <code class="docutils literal notranslate"><span class="pre">MPI_Finalize</span></code>, but the functions may also
check if MPI has been initialized and finalized (this is a common practice to
avoid accidentally calling <code class="docutils literal notranslate"><span class="pre">MPI_Init</span></code>/<code class="docutils literal notranslate"><span class="pre">MPI_Finalize</span></code> after MPI has already
been initialize/finalized). It is also conceivable that these functions do
additional initialization/finalization which requires MPI to be initialized, but
not yet finalized, e.g., calls to synchronize data.</p>
</section>
<section id="raii-interacting-with-traditional-solution">
<span id="id3"></span><h2>RAII Interacting With Traditional Solution<a class="headerlink" href="#raii-interacting-with-traditional-solution" title="Link to this heading"></a></h2>
<p>In <a class="reference internal" href="#traditional-solution"><span class="std std-ref">Traditional Solution</span></a> we noted that when a library provides its own
<code class="docutils literal notranslate"><span class="pre">initialize</span></code> / <code class="docutils literal notranslate"><span class="pre">finalize</span></code> functions (which we called “Scenario 2”) RAII
interactions become more complicated. It’s worth noting that Scenario 2 has two
sub-scenarios:</p>
<ol class="loweralpha simple">
<li><p>User should only call <code class="docutils literal notranslate"><span class="pre">initialize</span></code> and <code class="docutils literal notranslate"><span class="pre">finalize</span></code> if the library is
managing MPI.</p></li>
<li><p>The user should always call <code class="docutils literal notranslate"><span class="pre">initialize</span></code> and <code class="docutils literal notranslate"><span class="pre">finalize</span></code>.</p></li>
</ol>
<p>Each of these sub-scenarios can occur interact with ParallelZone in one of two
states: PZ started MPI or PZ did not start MPI. Sub-scenario a is essentially
the same as Scenario 1 in <a class="reference internal" href="#traditional-solution"><span class="std std-ref">Traditional Solution</span></a> if ParallelZone starts
MPI. If, however, the library starts MPI we have:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">initialize</span><span class="p">();</span><span class="w"> </span><span class="c1">// library starts MPI</span>
<span class="k">auto</span><span class="w"> </span><span class="n">comm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_mpi_communicator_from_library</span><span class="p">();</span>
<span class="n">RuntimeView</span><span class="w"> </span><span class="nf">rv</span><span class="p">(</span><span class="n">comm</span><span class="p">);</span><span class="w"> </span><span class="c1">// PZ uses MPI from library</span>

<span class="n">finalize</span><span class="p">();</span><span class="w"> </span><span class="c1">// library releases MPI</span>
<span class="c1">// end of code, rv is released</span>
</pre></div>
</div>
<p>This is fine so long as destruction of <code class="docutils literal notranslate"><span class="pre">rv</span></code> is guaranteed not to use any
MPI functions (which we ultimately will not be able to guarantee, but we’ll get
to that). For now we note that there is a better way to write this which will
work even if <code class="docutils literal notranslate"><span class="pre">rv</span></code> calls MPI functions, namely we force <code class="docutils literal notranslate"><span class="pre">rv</span></code> to go out of
scope before <code class="docutils literal notranslate"><span class="pre">finalize</span></code> is called:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">initialize</span><span class="p">();</span><span class="w"> </span><span class="c1">// library starts MPI</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">comm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_mpi_communicator_from_library</span><span class="p">();</span>
<span class="w">    </span><span class="n">RuntimeView</span><span class="w"> </span><span class="nf">rv</span><span class="p">(</span><span class="n">comm</span><span class="p">);</span><span class="w"> </span><span class="c1">// PZ uses MPI from library</span>
<span class="w">    </span><span class="c1">// rv is released</span>
<span class="p">}</span>

<span class="n">finalize</span><span class="p">();</span><span class="w"> </span><span class="c1">// library releases MPI</span>
<span class="c1">// end of code</span>
</pre></div>
</div>
<p>Moving on Scenario 2b, if the library starts MPI it is identical to when the
library starts MPI in Scenario 2a and no further comment is necessary. The
remaining condition is Scenario 2b with ParallelZone starting MPI:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RuntimeView</span><span class="w"> </span><span class="n">rv</span><span class="p">;</span><span class="w"> </span><span class="c1">// ParallelZone starts MPI</span>
<span class="k">auto</span><span class="w"> </span><span class="n">comm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rv</span><span class="p">.</span><span class="n">mpi_comm</span><span class="p">();</span>
<span class="n">initialize</span><span class="p">(</span><span class="n">comm</span><span class="p">);</span><span class="w"> </span><span class="c1">// library uses MPI from PZ</span>

<span class="n">finalize</span><span class="p">();</span>
<span class="c1">// end of code, PZ releases MPI</span>
</pre></div>
</div>
<p>This is okay as long as <code class="docutils literal notranslate"><span class="pre">rv</span></code> is guaranteed to be in scope when <code class="docutils literal notranslate"><span class="pre">finalize</span></code>
is called.</p>
</section>
<section id="raii-plus-encapsulation">
<h2>RAII Plus Encapsulation<a class="headerlink" href="#raii-plus-encapsulation" title="Link to this heading"></a></h2>
<p><a class="reference internal" href="#raii-interacting-with-traditional-solution"><span class="std std-ref">RAII Interacting With Traditional Solution</span></a> showed that our RAII solution
is fine as long as we control the order of destruction. This is a detail we’d
rather not leak to the user, especially if more initialization/finalization
functions are added later (or if some are removed). With the traditional
solution we can easily encapsulate this detail with something like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">initialize</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">library_a</span><span class="o">::</span><span class="n">initialize</span><span class="p">();</span>
<span class="w">    </span><span class="n">library_b</span><span class="o">::</span><span class="n">initialize</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">finalize</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">library_b</span><span class="o">::</span><span class="n">finalize</span><span class="p">();</span>
<span class="w">    </span><span class="n">library_a</span><span class="o">::</span><span class="n">finalize</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// User&#39;s code</span>
<span class="n">initialize</span><span class="p">();</span><span class="w"> </span><span class="c1">// A initializes MPI, then B uses A&#39;s MPI</span>

<span class="n">finalize</span><span class="p">();</span><span class="w"> </span><span class="c1">// B cleans up, then A finalizes MPI</span>
</pre></div>
</div>
<p>As shown, the order of initialization/finalization is guaranteed by creating
wrappers around sub-library initialization/finalization. Users rely on the
wrappers and never need to worry about the order.</p>
<p>So now what about RAII? Let’s start with Scenario 2b, and ParallelZone starting
MPI:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RuntimeView</span><span class="w"> </span><span class="nf">initialize</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">RuntimeView</span><span class="w"> </span><span class="n">rv</span><span class="p">;</span><span class="w"> </span><span class="c1">// PZ starts MPI</span>
<span class="w">    </span><span class="n">library_a</span><span class="o">::</span><span class="n">initialize</span><span class="p">(</span><span class="n">rv</span><span class="p">.</span><span class="n">mpi_comm</span><span class="p">());</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">rv</span><span class="p">;</span><span class="w"> </span><span class="c1">// Must keep rv alive</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">finalize</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">library_a</span><span class="o">::</span><span class="n">finalize</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// User&#39;s code</span>
<span class="k">auto</span><span class="w"> </span><span class="n">rv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initialize</span><span class="p">();</span>

<span class="n">finalize</span><span class="p">();</span><span class="w"> </span><span class="c1">// library finalizes</span>
<span class="c1">// end of code, PZ ends MPI</span>
</pre></div>
</div>
<p>While this works, it violates RAII because the user needs to remember to call
<code class="docutils literal notranslate"><span class="pre">finalize</span></code> before the code ends or else there will be a resource leak. The
entire point of RAII is to avoid the possibility of leaks. If we want our
<code class="docutils literal notranslate"><span class="pre">RuntimeView</span></code> to adhere to RAII we must find a way for the destructor of
<code class="docutils literal notranslate"><span class="pre">rv</span></code> to call <code class="docutils literal notranslate"><span class="pre">finalize</span></code> before it stops MPI. The easiest way to do this is
with callbacks:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RuntimeView</span><span class="w"> </span><span class="nf">initialize</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">RuntimeView</span><span class="w"> </span><span class="n">rv</span><span class="p">;</span><span class="w"> </span><span class="c1">// PZ starts MPI</span>
<span class="w">    </span><span class="n">library_a</span><span class="o">::</span><span class="n">initialize</span><span class="p">(</span><span class="n">rv</span><span class="p">.</span><span class="n">mpi_comm</span><span class="p">());</span>

<span class="w">    </span><span class="c1">// Register that rv must call finalize upon destruction</span>
<span class="w">    </span><span class="n">rv</span><span class="p">.</span><span class="n">stack_callback</span><span class="p">(</span><span class="n">library_a</span><span class="o">::</span><span class="n">finalize</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">rv</span><span class="p">;</span><span class="w"> </span><span class="c1">// Must keep rv alive</span>
<span class="p">}</span>

<span class="c1">// User&#39;s code</span>
<span class="k">auto</span><span class="w"> </span><span class="n">rv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initialize</span><span class="p">();</span>

<span class="c1">// end of code, PZ&#39;s dtor calls library_a::finalize() then ends MPI</span>
</pre></div>
</div>
</section>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>MPI leaks initialization/finalization concerns to all dependencies.</p></li>
<li><p>This has led to many libraries leaking those same details to their
dependencies too.</p></li>
<li><p>When ParallelZone manages MPI we can use RAII to avoid leaking those details
to our dependencies.</p></li>
<li><p>RAII however requires that <code class="docutils literal notranslate"><span class="pre">RuntimeView</span></code> be able to hold callbacks.</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="design/reflection.html" class="btn btn-neutral float-left" title="Reflection Design" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, NWChemEx Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
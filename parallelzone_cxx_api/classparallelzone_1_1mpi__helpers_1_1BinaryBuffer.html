<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>parallelzone: parallelzone::mpi_helpers::BinaryBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">parallelzone
   &#160;<span id="projectnumber">0.1.30</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>parallelzone</b></li><li class="navelem"><b>mpi_helpers</b></li><li class="navelem"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">parallelzone::mpi_helpers::BinaryBuffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Wrapper treating contiguous binary data according to C++17 standard.  
 <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="binary__buffer_8hpp_source.html">binary_buffer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab68607cedb802d14733269153a63e7b0"><td class="memItemLeft" align="right" valign="top"><a id="ab68607cedb802d14733269153a63e7b0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#ab68607cedb802d14733269153a63e7b0">pimpl_type</a> = <a class="el" href="classparallelzone_1_1mpi__helpers_1_1detail___1_1BinaryBufferPIMPLBase.html">detail_::BinaryBufferPIMPLBase</a></td></tr>
<tr class="memdesc:ab68607cedb802d14733269153a63e7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef of the class declaring the PIMPL's API. <br /></td></tr>
<tr class="separator:ab68607cedb802d14733269153a63e7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0fee95946de7048ba0d3f561f12dfc"><td class="memItemLeft" align="right" valign="top"><a id="a5a0fee95946de7048ba0d3f561f12dfc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a5a0fee95946de7048ba0d3f561f12dfc">value_type</a> = <a class="el" href="classparallelzone_1_1mpi__helpers_1_1detail___1_1BinaryBufferPIMPLBase.html#ab6bceb663250f11dd23520a8d017442b">pimpl_type::value_type</a></td></tr>
<tr class="memdesc:a5a0fee95946de7048ba0d3f561f12dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ultimately a typedef of <a class="el" href="classparallelzone_1_1mpi__helpers_1_1detail___1_1BinaryBufferPIMPLBase.html#ab6bceb663250f11dd23520a8d017442b" title="Type of a single byte in the buffer.">detail_::BinaryBufferPIMPLBase::value_type</a>. <br /></td></tr>
<tr class="separator:a5a0fee95946de7048ba0d3f561f12dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98300802f6c7405d1e8b0da3e90245e"><td class="memItemLeft" align="right" valign="top"><a id="aa98300802f6c7405d1e8b0da3e90245e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#aa98300802f6c7405d1e8b0da3e90245e">pointer</a> = <a class="el" href="classparallelzone_1_1mpi__helpers_1_1detail___1_1BinaryBufferPIMPLBase.html#a1a7bdec23dc720f80175a3c590cb6422">pimpl_type::pointer</a></td></tr>
<tr class="memdesc:aa98300802f6c7405d1e8b0da3e90245e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ultimately a typedef of <a class="el" href="classparallelzone_1_1mpi__helpers_1_1detail___1_1BinaryBufferPIMPLBase.html#a1a7bdec23dc720f80175a3c590cb6422" title="Type of a read/write pointer to a byte.">detail_::BinaryBufferPIMPLBase::pointer</a>. <br /></td></tr>
<tr class="separator:aa98300802f6c7405d1e8b0da3e90245e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc872b41c6c809bb0e8735c797580f0a"><td class="memItemLeft" align="right" valign="top"><a id="adc872b41c6c809bb0e8735c797580f0a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#adc872b41c6c809bb0e8735c797580f0a">const_pointer</a> = <a class="el" href="classparallelzone_1_1mpi__helpers_1_1detail___1_1BinaryBufferPIMPLBase.html#a733af0a430c8f4e2183ddb191b120d14">pimpl_type::const_pointer</a></td></tr>
<tr class="memdesc:adc872b41c6c809bb0e8735c797580f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ultimately a typedef of <a class="el" href="classparallelzone_1_1mpi__helpers_1_1detail___1_1BinaryBufferPIMPLBase.html#a733af0a430c8f4e2183ddb191b120d14" title="Type of a read-only pointer to a byte.">detail_::BinaryBufferPIMPLBase::const_pointer</a>. <br /></td></tr>
<tr class="separator:adc872b41c6c809bb0e8735c797580f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9b05385a260eee3dd5fe62fa207862"><td class="memItemLeft" align="right" valign="top"><a id="a2d9b05385a260eee3dd5fe62fa207862"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a2d9b05385a260eee3dd5fe62fa207862">iterator</a> = <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#aa98300802f6c7405d1e8b0da3e90245e">pointer</a></td></tr>
<tr class="memdesc:a2d9b05385a260eee3dd5fe62fa207862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of read/write iterator. <br /></td></tr>
<tr class="separator:a2d9b05385a260eee3dd5fe62fa207862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba167e6bdce67bd5ac79d396605fdd47"><td class="memItemLeft" align="right" valign="top"><a id="aba167e6bdce67bd5ac79d396605fdd47"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#aba167e6bdce67bd5ac79d396605fdd47">const_iterator</a> = <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#adc872b41c6c809bb0e8735c797580f0a">const_pointer</a></td></tr>
<tr class="memdesc:aba167e6bdce67bd5ac79d396605fdd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read/only iterator. <br /></td></tr>
<tr class="separator:aba167e6bdce67bd5ac79d396605fdd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1201536cd2acd692e57b229a7ca88a3e"><td class="memItemLeft" align="right" valign="top"><a id="a1201536cd2acd692e57b229a7ca88a3e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a1201536cd2acd692e57b229a7ca88a3e">size_type</a> = <a class="el" href="classparallelzone_1_1mpi__helpers_1_1detail___1_1BinaryBufferPIMPLBase.html#a979e93ada8aa3f3a77f1340594d2d560">pimpl_type::size_type</a></td></tr>
<tr class="memdesc:a1201536cd2acd692e57b229a7ca88a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ultimately a typedef of <a class="el" href="classparallelzone_1_1mpi__helpers_1_1detail___1_1BinaryBufferPIMPLBase.html#a979e93ada8aa3f3a77f1340594d2d560" title="Type used to indicate the number of bytes.">detail_::BinaryBufferPIMPLBase::size_type</a>. <br /></td></tr>
<tr class="separator:a1201536cd2acd692e57b229a7ca88a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0323921a03567c77ff306672b73f60"><td class="memItemLeft" align="right" valign="top"><a id="abc0323921a03567c77ff306672b73f60"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#abc0323921a03567c77ff306672b73f60">pimpl_pointer</a> = <a class="el" href="classparallelzone_1_1mpi__helpers_1_1detail___1_1BinaryBufferPIMPLBase.html#a0cf6ce4a3f2d728b02ba7d5df8ca75bf">pimpl_type::pointer_to_base</a></td></tr>
<tr class="memdesc:abc0323921a03567c77ff306672b73f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ultimately a typedef of <a class="el" href="classparallelzone_1_1mpi__helpers_1_1detail___1_1BinaryBufferPIMPLBase.html#a0cf6ce4a3f2d728b02ba7d5df8ca75bf" title="Type of a managed pointer to the base of the PIMPL.">detail_::BinaryBufferPIMPLBase::pointer_to_base</a>. <br /></td></tr>
<tr class="separator:abc0323921a03567c77ff306672b73f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a45fef61e2e58715afa8af5100c7414cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a45fef61e2e58715afa8af5100c7414cb">BinaryBuffer</a> () noexcept=default</td></tr>
<tr class="memdesc:a45fef61e2e58715afa8af5100c7414cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html" title="Wrapper treating contiguous binary data according to C++17 standard.">BinaryBuffer</a>.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a45fef61e2e58715afa8af5100c7414cb">More...</a><br /></td></tr>
<tr class="separator:a45fef61e2e58715afa8af5100c7414cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2a414a5306795f5f2f66b6da1ee3a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a9c2a414a5306795f5f2f66b6da1ee3a3">BinaryBuffer</a> (<a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a1201536cd2acd692e57b229a7ca88a3e">size_type</a> n)</td></tr>
<tr class="memdesc:a9c2a414a5306795f5f2f66b6da1ee3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html" title="Wrapper treating contiguous binary data according to C++17 standard.">BinaryBuffer</a> capable of holding <code>n</code> bytes.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a9c2a414a5306795f5f2f66b6da1ee3a3">More...</a><br /></td></tr>
<tr class="separator:a9c2a414a5306795f5f2f66b6da1ee3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd874860e3cda0c858c761e726e69db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a9dd874860e3cda0c858c761e726e69db">BinaryBuffer</a> (<a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#abc0323921a03567c77ff306672b73f60">pimpl_pointer</a> p) noexcept</td></tr>
<tr class="memdesc:a9dd874860e3cda0c858c761e726e69db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html" title="Wrapper treating contiguous binary data according to C++17 standard.">BinaryBuffer</a> with the provided state.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a9dd874860e3cda0c858c761e726e69db">More...</a><br /></td></tr>
<tr class="separator:a9dd874860e3cda0c858c761e726e69db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a92598d9fab1c78a1f10ff23161d1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a85a92598d9fab1c78a1f10ff23161d1c">BinaryBuffer</a> (const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;other)</td></tr>
<tr class="memdesc:a85a92598d9fab1c78a1f10ff23161d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes *this to a deep copy of <code>other</code>.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a85a92598d9fab1c78a1f10ff23161d1c">More...</a><br /></td></tr>
<tr class="separator:a85a92598d9fab1c78a1f10ff23161d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d894b84869cc7281a45825a2e09eb27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a7d894b84869cc7281a45825a2e09eb27">operator=</a> (const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;rhs)</td></tr>
<tr class="memdesc:a7d894b84869cc7281a45825a2e09eb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites the state in *this with a copy of <code>rhs</code>.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a7d894b84869cc7281a45825a2e09eb27">More...</a><br /></td></tr>
<tr class="separator:a7d894b84869cc7281a45825a2e09eb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8ab5c577198f886061bbba15d58b05"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#acd8ab5c577198f886061bbba15d58b05">BinaryBuffer</a> (<a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:acd8ab5c577198f886061bbba15d58b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes *this with the state contained in <code>other</code>.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#acd8ab5c577198f886061bbba15d58b05">More...</a><br /></td></tr>
<tr class="separator:acd8ab5c577198f886061bbba15d58b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29dc99a104ab2a20f8b3e2fd363e334b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a29dc99a104ab2a20f8b3e2fd363e334b">operator=</a> (<a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;&amp;rhs) noexcept=default</td></tr>
<tr class="memdesc:a29dc99a104ab2a20f8b3e2fd363e334b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites the state in *this with the state contained in <code>rhs</code>.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a29dc99a104ab2a20f8b3e2fd363e334b">More...</a><br /></td></tr>
<tr class="separator:a29dc99a104ab2a20f8b3e2fd363e334b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa07ba4c53d49e6c4f3b7114d499a44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a1aa07ba4c53d49e6c4f3b7114d499a44">swap</a> (<a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a1aa07ba4c53d49e6c4f3b7114d499a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the state of *this with <code>other</code>.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a1aa07ba4c53d49e6c4f3b7114d499a44">More...</a><br /></td></tr>
<tr class="separator:a1aa07ba4c53d49e6c4f3b7114d499a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8827a3fcc5ae0f263af6dff098227f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a2d9b05385a260eee3dd5fe62fa207862">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#aca8827a3fcc5ae0f263af6dff098227f">begin</a> () noexcept</td></tr>
<tr class="memdesc:aca8827a3fcc5ae0f263af6dff098227f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first byte in the buffer.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#aca8827a3fcc5ae0f263af6dff098227f">More...</a><br /></td></tr>
<tr class="separator:aca8827a3fcc5ae0f263af6dff098227f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5c902b5274814edf6e82aaf9e02b8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#aba167e6bdce67bd5ac79d396605fdd47">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a7a5c902b5274814edf6e82aaf9e02b8c">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a7a5c902b5274814edf6e82aaf9e02b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first byte in the buffer.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a7a5c902b5274814edf6e82aaf9e02b8c">More...</a><br /></td></tr>
<tr class="separator:a7a5c902b5274814edf6e82aaf9e02b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eed1b713896a42c4d54db5d7d93671b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a2d9b05385a260eee3dd5fe62fa207862">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a0eed1b713896a42c4d54db5d7d93671b">end</a> ()</td></tr>
<tr class="memdesc:a0eed1b713896a42c4d54db5d7d93671b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to just past the last byte.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a0eed1b713896a42c4d54db5d7d93671b">More...</a><br /></td></tr>
<tr class="separator:a0eed1b713896a42c4d54db5d7d93671b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0855ba5e7308b0f326de3a84f43c6e53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#aba167e6bdce67bd5ac79d396605fdd47">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a0855ba5e7308b0f326de3a84f43c6e53">end</a> () const</td></tr>
<tr class="memdesc:a0855ba5e7308b0f326de3a84f43c6e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to just past the last byte.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a0855ba5e7308b0f326de3a84f43c6e53">More...</a><br /></td></tr>
<tr class="separator:a0855ba5e7308b0f326de3a84f43c6e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b07ffee87c2829e895538df7a5a2b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#aa98300802f6c7405d1e8b0da3e90245e">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a71b07ffee87c2829e895538df7a5a2b2">data</a> () noexcept</td></tr>
<tr class="memdesc:a71b07ffee87c2829e895538df7a5a2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer to the underlying buffer.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a71b07ffee87c2829e895538df7a5a2b2">More...</a><br /></td></tr>
<tr class="separator:a71b07ffee87c2829e895538df7a5a2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac007f71dc45b2e4d45029a4cc4183236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#adc872b41c6c809bb0e8735c797580f0a">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#ac007f71dc45b2e4d45029a4cc4183236">data</a> () const noexcept</td></tr>
<tr class="memdesc:ac007f71dc45b2e4d45029a4cc4183236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer to the underlying buffer.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#ac007f71dc45b2e4d45029a4cc4183236">More...</a><br /></td></tr>
<tr class="separator:ac007f71dc45b2e4d45029a4cc4183236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af517ba67a62ad348b11cd4cffa9eeaf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a1201536cd2acd692e57b229a7ca88a3e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#af517ba67a62ad348b11cd4cffa9eeaf1">size</a> () const noexcept</td></tr>
<tr class="memdesc:af517ba67a62ad348b11cd4cffa9eeaf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes in this buffer.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#af517ba67a62ad348b11cd4cffa9eeaf1">More...</a><br /></td></tr>
<tr class="separator:af517ba67a62ad348b11cd4cffa9eeaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4f99a532222ccd2ec1c46bb1c23f00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#afa4f99a532222ccd2ec1c46bb1c23f00">operator==</a> (const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:afa4f99a532222ccd2ec1c46bb1c23f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if *this is value equal to <code>rhs</code>.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#afa4f99a532222ccd2ec1c46bb1c23f00">More...</a><br /></td></tr>
<tr class="separator:afa4f99a532222ccd2ec1c46bb1c23f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaee27ff70f9d848efb7a9e5506fe580"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#afaee27ff70f9d848efb7a9e5506fe580">operator!=</a> (const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:afaee27ff70f9d848efb7a9e5506fe580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if *this is different than <code>rhs</code>.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#afaee27ff70f9d848efb7a9e5506fe580">More...</a><br /></td></tr>
<tr class="separator:afaee27ff70f9d848efb7a9e5506fe580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa776ec4ddc61e3c7eb19852e6fe775da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#aa776ec4ddc61e3c7eb19852e6fe775da">operator BinaryView</a> () noexcept</td></tr>
<tr class="memdesc:aa776ec4ddc61e3c7eb19852e6fe775da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows implicit conversion to <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryView.html" title="A view of read/write bytes.">BinaryView</a>.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#aa776ec4ddc61e3c7eb19852e6fe775da">More...</a><br /></td></tr>
<tr class="separator:aa776ec4ddc61e3c7eb19852e6fe775da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418288b6e45a34b3801df67855351652"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a418288b6e45a34b3801df67855351652">operator ConstBinaryView</a> () const noexcept</td></tr>
<tr class="memdesc:a418288b6e45a34b3801df67855351652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows implicit conversion to <a class="el" href="classparallelzone_1_1mpi__helpers_1_1ConstBinaryView.html" title="A view of read-only bytes.">ConstBinaryView</a>.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a418288b6e45a34b3801df67855351652">More...</a><br /></td></tr>
<tr class="separator:a418288b6e45a34b3801df67855351652"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a6220c22aa9a8d294e5cf9d0cbbcb5895"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6220c22aa9a8d294e5cf9d0cbbcb5895"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a6220c22aa9a8d294e5cf9d0cbbcb5895">make_binary_buffer</a> (T &amp;&amp;input)</td></tr>
<tr class="memdesc:a6220c22aa9a8d294e5cf9d0cbbcb5895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the process of creating a binary view of an object of type <code>T</code>.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a6220c22aa9a8d294e5cf9d0cbbcb5895">More...</a><br /></td></tr>
<tr class="separator:a6220c22aa9a8d294e5cf9d0cbbcb5895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8e8223950a395686063712812c11d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf8e8223950a395686063712812c11d5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#abf8e8223950a395686063712812c11d5">from_binary_buffer</a> (const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;buffer)</td></tr>
<tr class="memdesc:abf8e8223950a395686063712812c11d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the process of going from a <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html" title="Wrapper treating contiguous binary data according to C++17 standard.">BinaryBuffer</a> back to an object.  <a href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#abf8e8223950a395686063712812c11d5">More...</a><br /></td></tr>
<tr class="separator:abf8e8223950a395686063712812c11d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Wrapper treating contiguous binary data according to C++17 standard. </p>
<p>The C++17 standard introduces the <code>std::byte</code> class for representing a byte of binary data. Unfortunately, there's some trickery involved when trying to interface the <code>std::byte</code> class with pre-C++17 binary data representations (notably std::string). This class hides that trickery from the user making it easier to handle binary data in a manner consistent with the C++17 (and future) standard.</p>
<dl class="section note"><dt>Note</dt><dd>The API of this class exposes raw pointers. This is for API compatibility with MPI. The memory for those pointers is owned by *this, meaning users can modify the value pointed at, but should not otherwise modify the pointer. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a45fef61e2e58715afa8af5100c7414cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fef61e2e58715afa8af5100c7414cb">&#9670;&nbsp;</a></span>BinaryBuffer() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">parallelzone::mpi_helpers::BinaryBuffer::BinaryBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html" title="Wrapper treating contiguous binary data according to C++17 standard.">BinaryBuffer</a>. </p>
<p>Default constructed <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html" title="Wrapper treating contiguous binary data according to C++17 standard.">BinaryBuffer</a> instances do not manage any memory. Default constructed <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html" title="Wrapper treating contiguous binary data according to C++17 standard.">BinaryBuffer</a> instances are indistinguishable from <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html" title="Wrapper treating contiguous binary data according to C++17 standard.">BinaryBuffer</a> instances which contain a PIMPL wrapping a buffer of size 0.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c2a414a5306795f5f2f66b6da1ee3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2a414a5306795f5f2f66b6da1ee3a3">&#9670;&nbsp;</a></span>BinaryBuffer() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">parallelzone::mpi_helpers::BinaryBuffer::BinaryBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a1201536cd2acd692e57b229a7ca88a3e">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html" title="Wrapper treating contiguous binary data according to C++17 standard.">BinaryBuffer</a> capable of holding <code>n</code> bytes. </p>
<p>This ctor initializes *this to an <code>n</code> byte buffer. Each byte is set to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The size of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9dd874860e3cda0c858c761e726e69db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd874860e3cda0c858c761e726e69db">&#9670;&nbsp;</a></span>BinaryBuffer() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">parallelzone::mpi_helpers::BinaryBuffer::BinaryBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#abc0323921a03567c77ff306672b73f60">pimpl_pointer</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html" title="Wrapper treating contiguous binary data according to C++17 standard.">BinaryBuffer</a> with the provided state. </p>
<p>This is the primary ctor, although users should not directly call it. Users should instead prefer the convenience make_binary_buffer free functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>A pointer to the PIMPL which implements *this. The actual PIMPL is taken as a pointer to the base class so as to type erase the details of the actual buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85a92598d9fab1c78a1f10ff23161d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a92598d9fab1c78a1f10ff23161d1c">&#9670;&nbsp;</a></span>BinaryBuffer() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">parallelzone::mpi_helpers::BinaryBuffer::BinaryBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes *this to a deep copy of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The binary buffer we are copying. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd8ab5c577198f886061bbba15d58b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8ab5c577198f886061bbba15d58b05">&#9670;&nbsp;</a></span>BinaryBuffer() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">parallelzone::mpi_helpers::BinaryBuffer::BinaryBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes *this with the state contained in <code>other</code>. </p>
<p>Standard move ctor. After this operation, all references to the state in <code>other</code> are still valid except that they now point to state in *this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The buffer to take the state from. After this call <code>other</code> is in a state undistinguishable from default construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7a5c902b5274814edf6e82aaf9e02b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5c902b5274814edf6e82aaf9e02b8c">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#aba167e6bdce67bd5ac79d396605fdd47">const_iterator</a> parallelzone::mpi_helpers::BinaryBuffer::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first byte in the buffer. </p>
<p>The iterator resulting from this method is read-only. If the buffer is empty then de-referencing the returned iterator is undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>If <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#af517ba67a62ad348b11cd4cffa9eeaf1" title="Returns the number of bytes in this buffer.">size()</a> &gt; 0, an iterator pointing to the first byte in the buffer. For <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#af517ba67a62ad348b11cd4cffa9eeaf1" title="Returns the number of bytes in this buffer.">size()</a> == 0 this returns <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a0eed1b713896a42c4d54db5d7d93671b" title="Returns an iterator to just past the last byte.">end()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca8827a3fcc5ae0f263af6dff098227f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8827a3fcc5ae0f263af6dff098227f">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a2d9b05385a260eee3dd5fe62fa207862">iterator</a> parallelzone::mpi_helpers::BinaryBuffer::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first byte in the buffer. </p>
<p>As long as this buffer is non-empty, the iterator returned by this method can be used to modify the wrapped buffer. If the buffer is empty then de-referencing the returned iterator is undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>If <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#af517ba67a62ad348b11cd4cffa9eeaf1" title="Returns the number of bytes in this buffer.">size()</a> &gt; 0, an iterator pointing to the first byte in the buffer. For <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#af517ba67a62ad348b11cd4cffa9eeaf1" title="Returns the number of bytes in this buffer.">size()</a> == 0 this returns <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a0eed1b713896a42c4d54db5d7d93671b" title="Returns an iterator to just past the last byte.">end()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac007f71dc45b2e4d45029a4cc4183236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac007f71dc45b2e4d45029a4cc4183236">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#adc872b41c6c809bb0e8735c797580f0a">const_pointer</a> parallelzone::mpi_helpers::BinaryBuffer::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a raw pointer to the underlying buffer. </p>
<p>The underlying buffer is guaranteed to be contiguous. This method can be used to obtain a raw_pointer to the first byte. Subsequent bytes can then be accessed via pointer arithmetic. The pointer returned by this method.</p>
<dl class="section return"><dt>Returns</dt><dd>If <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#af517ba67a62ad348b11cd4cffa9eeaf1" title="Returns the number of bytes in this buffer.">size()</a> &gt; 0 this will be a pointer to the first byte in the underlying buffer. If <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#af517ba67a62ad348b11cd4cffa9eeaf1" title="Returns the number of bytes in this buffer.">size()</a> == 0 this will be the nullptr.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71b07ffee87c2829e895538df7a5a2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b07ffee87c2829e895538df7a5a2b2">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#aa98300802f6c7405d1e8b0da3e90245e">pointer</a> parallelzone::mpi_helpers::BinaryBuffer::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a raw pointer to the underlying buffer. </p>
<p>The underlying buffer is guaranteed to be contiguous. This method can be used to obtain a raw_pointer to the first byte. Subsequent bytes can then be accessed via pointer arithmetic. The pointer returned by this method can be used to change the values in the buffer, but users should not modify the pointer itself.</p>
<dl class="section return"><dt>Returns</dt><dd>If <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#af517ba67a62ad348b11cd4cffa9eeaf1" title="Returns the number of bytes in this buffer.">size()</a> &gt; 0 this will be a pointer to the first byte in the underlying buffer. If <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#af517ba67a62ad348b11cd4cffa9eeaf1" title="Returns the number of bytes in this buffer.">size()</a> == 0 this will be the nullptr.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0eed1b713896a42c4d54db5d7d93671b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eed1b713896a42c4d54db5d7d93671b">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a2d9b05385a260eee3dd5fe62fa207862">iterator</a> parallelzone::mpi_helpers::BinaryBuffer::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to just past the last byte. </p>
<p>The iterator returned by this method is meant to be used as a semaphore for stopping iteration. In particular this means that the iterator should not be de-referenced.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to just past the last byte.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0855ba5e7308b0f326de3a84f43c6e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0855ba5e7308b0f326de3a84f43c6e53">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#aba167e6bdce67bd5ac79d396605fdd47">const_iterator</a> parallelzone::mpi_helpers::BinaryBuffer::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to just past the last byte. </p>
<p>The iterator returned by this method is meant to be used as a semaphore for stopping iteration. In particular this means that the iterator should not be de-referenced.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to just past the last byte.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa776ec4ddc61e3c7eb19852e6fe775da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa776ec4ddc61e3c7eb19852e6fe775da">&#9670;&nbsp;</a></span>operator BinaryView()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">parallelzone::mpi_helpers::BinaryBuffer::operator <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryView.html">BinaryView</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows implicit conversion to <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryView.html" title="A view of read/write bytes.">BinaryView</a>. </p>
<p><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryView.html" title="A view of read/write bytes.">BinaryView</a> objects are used as read/write references to <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html" title="Wrapper treating contiguous binary data according to C++17 standard.">BinaryBuffer</a> instances. This method allows <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryView.html" title="A view of read/write bytes.">BinaryView</a> instances to be implicitly constructed from <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html" title="Wrapper treating contiguous binary data according to C++17 standard.">BinaryBuffer</a> objects, analogous to how references are implicitly constructed for normal types.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryView.html" title="A view of read/write bytes.">BinaryView</a> instance aliasing the binary buffer in *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a418288b6e45a34b3801df67855351652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418288b6e45a34b3801df67855351652">&#9670;&nbsp;</a></span>operator ConstBinaryView()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">parallelzone::mpi_helpers::BinaryBuffer::operator <a class="el" href="classparallelzone_1_1mpi__helpers_1_1ConstBinaryView.html">ConstBinaryView</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows implicit conversion to <a class="el" href="classparallelzone_1_1mpi__helpers_1_1ConstBinaryView.html" title="A view of read-only bytes.">ConstBinaryView</a>. </p>
<p><a class="el" href="classparallelzone_1_1mpi__helpers_1_1ConstBinaryView.html" title="A view of read-only bytes.">ConstBinaryView</a> objects are used as read-only references to <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html" title="Wrapper treating contiguous binary data according to C++17 standard.">BinaryBuffer</a> instances. This method allows <a class="el" href="classparallelzone_1_1mpi__helpers_1_1ConstBinaryView.html" title="A view of read-only bytes.">ConstBinaryView</a> instances to be implicitly constructed from <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html" title="Wrapper treating contiguous binary data according to C++17 standard.">BinaryBuffer</a> objects, analogous to how const references are implicitly constructed for normal types.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classparallelzone_1_1mpi__helpers_1_1ConstBinaryView.html" title="A view of read-only bytes.">ConstBinaryView</a> instance aliasing the binary buffer in *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afaee27ff70f9d848efb7a9e5506fe580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaee27ff70f9d848efb7a9e5506fe580">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool parallelzone::mpi_helpers::BinaryBuffer::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if *this is different than <code>rhs</code>. </p>
<p>This method defines "different" as not value equal. See the description of operator== for the definition of value equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance we are comparing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if *this is value equal to <code>rhs</code> and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29dc99a104ab2a20f8b3e2fd363e334b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29dc99a104ab2a20f8b3e2fd363e334b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a>&amp; parallelzone::mpi_helpers::BinaryBuffer::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrites the state in *this with the state contained in <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>The buffer to take the state from. After this call <code>rhs</code> is in a state undistinguishable from default construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this, but now containing the state of <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d894b84869cc7281a45825a2e09eb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d894b84869cc7281a45825a2e09eb27">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a>&amp; parallelzone::mpi_helpers::BinaryBuffer::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrites the state in *this with a copy of <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this after its state has been replaced with a deep copy of <code>rhs</code>. </dd></dl>

</div>
</div>
<a id="afa4f99a532222ccd2ec1c46bb1c23f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4f99a532222ccd2ec1c46bb1c23f00">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool parallelzone::mpi_helpers::BinaryBuffer::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if *this is value equal to <code>rhs</code>. </p>
<p>For the purposes of <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html" title="Wrapper treating contiguous binary data according to C++17 standard.">BinaryBuffer</a>, value equal means that *this and <code>rhs</code> both hold the same number of bytes (as determined by <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#af517ba67a62ad348b11cd4cffa9eeaf1" title="Returns the number of bytes in this buffer.">size()</a>) and that byte-by-byte *this compares equal to <code>rhs</code>. In particular this means *this and <code>rhs</code> may use different underlying buffers and that this-&gt;<a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a71b07ffee87c2829e895538df7a5a2b2" title="Returns a raw pointer to the underlying buffer.">data()</a> need not equal rhs.data().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance we are comparing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if *this is value equal to <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw gurantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af517ba67a62ad348b11cd4cffa9eeaf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af517ba67a62ad348b11cd4cffa9eeaf1">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#a1201536cd2acd692e57b229a7ca88a3e">size_type</a> parallelzone::mpi_helpers::BinaryBuffer::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes in this buffer. </p>
<p>This method returns the number of bytes in the buffer. Of note, this means that if the underlying buffer has elements larger than a byte, this method will still return the number of elements in bytes. Also worth mentioning an empty buffer has <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html#af517ba67a62ad348b11cd4cffa9eeaf1" title="Returns the number of bytes in this buffer.">size()</a> == 0.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1aa07ba4c53d49e6c4f3b7114d499a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa07ba4c53d49e6c4f3b7114d499a44">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void parallelzone::mpi_helpers::BinaryBuffer::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the state of *this with <code>other</code>. </p>
<p>This method simply swaps the PIMPL which is in *this with the PIMPL that is in <code>other</code>. After the operations all pointers to state in *this / <code>other</code> remain valid, except that the referenced state now lives in <code>other</code> / *this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The instance to exchange state with. After this call <code>other</code> will contain the state which was previously in *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="abf8e8223950a395686063712812c11d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8e8223950a395686063712812c11d5">&#9670;&nbsp;</a></span>from_binary_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T from_binary_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the process of going from a <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html" title="Wrapper treating contiguous binary data according to C++17 standard.">BinaryBuffer</a> back to an object. </p>
<p>This function is a convenience function for creating an object from an array of contiguous binary data. The <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html" title="Wrapper treating contiguous binary data according to C++17 standard.">BinaryBuffer</a> is assumed to contain the serialized form of an object of type <code>T</code> if NeedsSerialized&lt;T&gt;::value is true. Otherwise it is assumed that <code>T</code> can be created by copying the data out of <code>buffer</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type we want to convert the binary data to. <code>T</code> is an explicit template type parameter and must be specified by the user. <code>T</code> should be an unqualified type (<em>i.e.</em>, no const, references, or the like). If needs_serialized&lt;T&gt; is false we assume that T has a range ctor that can be used to fill in a new <code>T</code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The contiguous binary buffer we are making the object from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An instance of type <code>T</code> initialized from the binary data in <code>buffer</code>. </dd></dl>

</div>
</div>
<a id="a6220c22aa9a8d294e5cf9d0cbbcb5895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6220c22aa9a8d294e5cf9d0cbbcb5895">&#9670;&nbsp;</a></span>make_binary_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a> make_binary_buffer </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the process of creating a binary view of an object of type <code>T</code>. </p>
<p>This function will create a <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryView.html" title="A view of read/write bytes.">BinaryView</a> of <code>input</code> in an intelligent manner. By intelligent we mean that it will try to avoid serializing <code>input</code> if at all possible. Whether <code>input</code> needs to be serialized is controlled by the trait <code><a class="el" href="structparallelzone_1_1mpi__helpers_1_1NeedsSerialized.html" title="Determines if T needs to be serialized for MPI communication.">NeedsSerialized</a></code>. If <code>input</code> needs to be serialized the resulting <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryView.html" title="A view of read/write bytes.">BinaryView</a> will be responsible for managing the lifetime of the buffer <code>input</code> is serialized into, if <code>input</code> does not need to be serialized the user is responsible for ensuring <code>input</code> remains in the same state until the resulting <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryView.html" title="A view of read/write bytes.">BinaryView</a> is destroyed.</p>
<dl class="section note"><dt>Note</dt><dd>In practice this function is usually called and the result consumed immediately. This greatly simplifies lifetime management.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of <code>input</code> is std::decay_t&lt;T&gt;. The type <code>T</code> captures the semantics of how <code>input</code> was passed to make_binary_view ( <em>i.e.</em>, is it cv-qualified, was it passed by reference?, etc.). <code>T</code> is an implicit template parameter and does not need to be specified by the user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The object we want a binary view of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryView.html" title="A view of read/write bytes.">BinaryView</a> of <code>input</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/parallelzone/mpi_helpers/binary_buffer/<a class="el" href="binary__buffer_8hpp_source.html">binary_buffer.hpp</a></li>
<li>include/parallelzone/mpi_helpers/binary_buffer/<a class="el" href="binary__buffer_8ipp.html">binary_buffer.ipp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>parallelzone: parallelzone::mpi_helpers::CommPP Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">parallelzone
   &#160;<span id="projectnumber">0.1.34</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>parallelzone</b></li><li class="navelem"><b>mpi_helpers</b></li><li class="navelem"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classparallelzone_1_1mpi__helpers_1_1CommPP-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">parallelzone::mpi_helpers::CommPP Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A little wrapper around an MPI communicator to make it more C++ friendly.  
 <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="commpp_8hpp_source.html">commpp.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a46e30c53a274efd23f0ba2af49faa98d"><td class="memItemLeft" align="right" valign="top"><a id="a46e30c53a274efd23f0ba2af49faa98d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a46e30c53a274efd23f0ba2af49faa98d">pimpl_type</a> = <a class="el" href="classparallelzone_1_1mpi__helpers_1_1detail___1_1CommPPPIMPL.html">detail_::CommPPPIMPL</a></td></tr>
<tr class="memdesc:a46e30c53a274efd23f0ba2af49faa98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the class implementing *this. <br /></td></tr>
<tr class="separator:a46e30c53a274efd23f0ba2af49faa98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee768cd31f3c6592033c8c4b9ef1511"><td class="memItemLeft" align="right" valign="top"><a id="acee768cd31f3c6592033c8c4b9ef1511"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#acee768cd31f3c6592033c8c4b9ef1511">pimpl_pointer</a> = std::unique_ptr&lt; <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a46e30c53a274efd23f0ba2af49faa98d">pimpl_type</a> &gt;</td></tr>
<tr class="memdesc:acee768cd31f3c6592033c8c4b9ef1511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to the PIMPL. <br /></td></tr>
<tr class="separator:acee768cd31f3c6592033c8c4b9ef1511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d74cca17008c02706ab32ce0ed8374"><td class="memItemLeft" align="right" valign="top"><a id="ac3d74cca17008c02706ab32ce0ed8374"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#ac3d74cca17008c02706ab32ce0ed8374">mpi_comm_type</a> = MPI_Comm</td></tr>
<tr class="memdesc:ac3d74cca17008c02706ab32ce0ed8374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a bare MPI communicator. <br /></td></tr>
<tr class="separator:ac3d74cca17008c02706ab32ce0ed8374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20854b131da254b8288d0fbd0b64be83"><td class="memItemLeft" align="right" valign="top"><a id="a20854b131da254b8288d0fbd0b64be83"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a20854b131da254b8288d0fbd0b64be83">size_type</a> = int</td></tr>
<tr class="memdesc:a20854b131da254b8288d0fbd0b64be83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for indexing and offsets. <br /></td></tr>
<tr class="separator:a20854b131da254b8288d0fbd0b64be83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ed5fa6980dcdb5811d08fe3bfb9692"><td class="memItemLeft" align="right" valign="top"><a id="a31ed5fa6980dcdb5811d08fe3bfb9692"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a31ed5fa6980dcdb5811d08fe3bfb9692">binary_type</a> = <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryBuffer.html">BinaryBuffer</a></td></tr>
<tr class="memdesc:a31ed5fa6980dcdb5811d08fe3bfb9692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a block of binary data. <br /></td></tr>
<tr class="separator:a31ed5fa6980dcdb5811d08fe3bfb9692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a03ce7e6ca24f81fc97c87f83c986b2"><td class="memItemLeft" align="right" valign="top"><a id="a2a03ce7e6ca24f81fc97c87f83c986b2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a2a03ce7e6ca24f81fc97c87f83c986b2">binary_reference</a> = <a class="el" href="classparallelzone_1_1mpi__helpers_1_1BinaryView.html">BinaryView</a></td></tr>
<tr class="memdesc:a2a03ce7e6ca24f81fc97c87f83c986b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read/write reference to a block of binary data. <br /></td></tr>
<tr class="separator:a2a03ce7e6ca24f81fc97c87f83c986b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22722fe3a989dd052d37cacab18ccbc"><td class="memItemLeft" align="right" valign="top"><a id="af22722fe3a989dd052d37cacab18ccbc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#af22722fe3a989dd052d37cacab18ccbc">const_binary_reference</a> = <a class="el" href="classparallelzone_1_1mpi__helpers_1_1ConstBinaryView.html">ConstBinaryView</a></td></tr>
<tr class="memdesc:af22722fe3a989dd052d37cacab18ccbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to a block of binary data. <br /></td></tr>
<tr class="separator:af22722fe3a989dd052d37cacab18ccbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4596253d9e035175f9c5d05794f6580"><td class="memItemLeft" align="right" valign="top"><a id="ab4596253d9e035175f9c5d05794f6580"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#ab4596253d9e035175f9c5d05794f6580">binary_gather_return</a> = gather_return_t&lt; <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a31ed5fa6980dcdb5811d08fe3bfb9692">binary_type</a> &gt;</td></tr>
<tr class="memdesc:ab4596253d9e035175f9c5d05794f6580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type returned by the binary version of gather. <br /></td></tr>
<tr class="separator:ab4596253d9e035175f9c5d05794f6580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba97438bea80c9caa7d60688d7f313fa"><td class="memItemLeft" align="right" valign="top"><a id="aba97438bea80c9caa7d60688d7f313fa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#aba97438bea80c9caa7d60688d7f313fa">gatherv_pair</a> = std::pair&lt; <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a31ed5fa6980dcdb5811d08fe3bfb9692">binary_type</a>, std::vector&lt; <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a20854b131da254b8288d0fbd0b64be83">size_type</a> &gt; &gt;</td></tr>
<tr class="memdesc:aba97438bea80c9caa7d60688d7f313fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a buffer and the sizes per rank. <br /></td></tr>
<tr class="separator:aba97438bea80c9caa7d60688d7f313fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ace65a322c1401ddaa5219c8a18b2fd"><td class="memItemLeft" align="right" valign="top"><a id="a8ace65a322c1401ddaa5219c8a18b2fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a8ace65a322c1401ddaa5219c8a18b2fd">binary_gatherv_return</a> = std::optional&lt; <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#aba97438bea80c9caa7d60688d7f313fa">gatherv_pair</a> &gt;</td></tr>
<tr class="memdesc:a8ace65a322c1401ddaa5219c8a18b2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type returned by the binary version of gatherv. <br /></td></tr>
<tr class="separator:a8ace65a322c1401ddaa5219c8a18b2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa0152b0d5c3fecb751e4d166eefd7b"><td class="memTemplParams" colspan="2"><a id="a2fa0152b0d5c3fecb751e4d166eefd7b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2fa0152b0d5c3fecb751e4d166eefd7b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a2fa0152b0d5c3fecb751e4d166eefd7b">gather_return_type</a> = gather_return_t&lt; std::decay_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a2fa0152b0d5c3fecb751e4d166eefd7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type returned by gather (and gatherv) given an object of type <code>T</code>. <br /></td></tr>
<tr class="separator:a2fa0152b0d5c3fecb751e4d166eefd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af380842c525736532d737f78aada76d3"><td class="memTemplParams" colspan="2"><a id="af380842c525736532d737f78aada76d3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af380842c525736532d737f78aada76d3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#af380842c525736532d737f78aada76d3">all_gather_return_type</a> = typename <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a2fa0152b0d5c3fecb751e4d166eefd7b">gather_return_type</a>&lt; T &gt;::value_type</td></tr>
<tr class="memdesc:af380842c525736532d737f78aada76d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type from all gather (and all gatherv) given object of type <code>T</code>. <br /></td></tr>
<tr class="separator:af380842c525736532d737f78aada76d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878084730a152f609d894ab893309947"><td class="memTemplParams" colspan="2"><a id="a878084730a152f609d894ab893309947"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a878084730a152f609d894ab893309947"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a878084730a152f609d894ab893309947">reduce_return_type</a> = std::optional&lt; std::decay_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a878084730a152f609d894ab893309947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type returned by rooted reduce. <br /></td></tr>
<tr class="separator:a878084730a152f609d894ab893309947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee605191b4a081c7538abfda709177b8"><td class="memTemplParams" colspan="2"><a id="aee605191b4a081c7538abfda709177b8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee605191b4a081c7538abfda709177b8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#aee605191b4a081c7538abfda709177b8">all_reduce_return_type</a> = typename <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a878084730a152f609d894ab893309947">reduce_return_type</a>&lt; T &gt;::value_type</td></tr>
<tr class="memdesc:aee605191b4a081c7538abfda709177b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type returned by all reduce. <br /></td></tr>
<tr class="separator:aee605191b4a081c7538abfda709177b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acfd0b7376675a7b4b7e5d43b7f357f3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#acfd0b7376675a7b4b7e5d43b7f357f3b">CommPP</a> () noexcept</td></tr>
<tr class="memdesc:acfd0b7376675a7b4b7e5d43b7f357f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a null communicator.  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#acfd0b7376675a7b4b7e5d43b7f357f3b">More...</a><br /></td></tr>
<tr class="separator:acfd0b7376675a7b4b7e5d43b7f357f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2b3738bafcb60e3dd2f2da0be94b19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a1e2b3738bafcb60e3dd2f2da0be94b19">CommPP</a> (<a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#ac3d74cca17008c02706ab32ce0ed8374">mpi_comm_type</a> <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#af088c30e7b0c55af6db18ec21348b54a">comm</a>)</td></tr>
<tr class="memdesc:a1e2b3738bafcb60e3dd2f2da0be94b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a communicator which wraps <code>comm</code>.  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a1e2b3738bafcb60e3dd2f2da0be94b19">More...</a><br /></td></tr>
<tr class="separator:a1e2b3738bafcb60e3dd2f2da0be94b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d6205deb2e6dbb3d52526e4316c826"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a37d6205deb2e6dbb3d52526e4316c826">CommPP</a> (const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp;other)</td></tr>
<tr class="memdesc:a37d6205deb2e6dbb3d52526e4316c826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html" title="A little wrapper around an MPI communicator to make it more C++ friendly.">CommPP</a> instance which is a "deep" copy of <code>other</code>.  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a37d6205deb2e6dbb3d52526e4316c826">More...</a><br /></td></tr>
<tr class="separator:a37d6205deb2e6dbb3d52526e4316c826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95478ed25c725a635298e86af605ac69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a95478ed25c725a635298e86af605ac69">CommPP</a> (<a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a95478ed25c725a635298e86af605ac69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html" title="A little wrapper around an MPI communicator to make it more C++ friendly.">CommPP</a> by taking ownership of the state in <code>other</code>.  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a95478ed25c725a635298e86af605ac69">More...</a><br /></td></tr>
<tr class="separator:a95478ed25c725a635298e86af605ac69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6b12af2ab5597be387126a32d9d7d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#abe6b12af2ab5597be387126a32d9d7d1">operator=</a> (const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp;rhs)</td></tr>
<tr class="memdesc:abe6b12af2ab5597be387126a32d9d7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes *this a deep copy of <code>other</code>.  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#abe6b12af2ab5597be387126a32d9d7d1">More...</a><br /></td></tr>
<tr class="separator:abe6b12af2ab5597be387126a32d9d7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f8f1084fb3fd365af2bb3990d2803a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#ac4f8f1084fb3fd365af2bb3990d2803a">operator=</a> (<a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ac4f8f1084fb3fd365af2bb3990d2803a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers the state in <code>other</code> to *this.  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#ac4f8f1084fb3fd365af2bb3990d2803a">More...</a><br /></td></tr>
<tr class="separator:ac4f8f1084fb3fd365af2bb3990d2803a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada65ba5aea0d2a57e75dbee4ad9002a3"><td class="memItemLeft" align="right" valign="top"><a id="ada65ba5aea0d2a57e75dbee4ad9002a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#ada65ba5aea0d2a57e75dbee4ad9002a3">~CommPP</a> () noexcept</td></tr>
<tr class="memdesc:ada65ba5aea0d2a57e75dbee4ad9002a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default dtor. <br /></td></tr>
<tr class="separator:ada65ba5aea0d2a57e75dbee4ad9002a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af088c30e7b0c55af6db18ec21348b54a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#ac3d74cca17008c02706ab32ce0ed8374">mpi_comm_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#af088c30e7b0c55af6db18ec21348b54a">comm</a> () const noexcept</td></tr>
<tr class="memdesc:af088c30e7b0c55af6db18ec21348b54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the underlying MPI communicator.  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#af088c30e7b0c55af6db18ec21348b54a">More...</a><br /></td></tr>
<tr class="separator:af088c30e7b0c55af6db18ec21348b54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1145df087b6306bab858288116cdc30f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a20854b131da254b8288d0fbd0b64be83">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a1145df087b6306bab858288116cdc30f">size</a> () const noexcept</td></tr>
<tr class="memdesc:a1145df087b6306bab858288116cdc30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ranks manged by <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#af088c30e7b0c55af6db18ec21348b54a" title="Returns a handle to the underlying MPI communicator.">comm()</a>  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a1145df087b6306bab858288116cdc30f">More...</a><br /></td></tr>
<tr class="separator:a1145df087b6306bab858288116cdc30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a8b81c9b466b24e55575c9b01863cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a20854b131da254b8288d0fbd0b64be83">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#ad1a8b81c9b466b24e55575c9b01863cb">me</a> () const noexcept</td></tr>
<tr class="memdesc:ad1a8b81c9b466b24e55575c9b01863cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank of the current process.  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#ad1a8b81c9b466b24e55575c9b01863cb">More...</a><br /></td></tr>
<tr class="separator:ad1a8b81c9b466b24e55575c9b01863cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623ba9a8840dbbb634544eda82ef3da2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a623ba9a8840dbbb634544eda82ef3da2">swap</a> (<a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a623ba9a8840dbbb634544eda82ef3da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the state in *this with that in <code>other</code>.  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a623ba9a8840dbbb634544eda82ef3da2">More...</a><br /></td></tr>
<tr class="separator:a623ba9a8840dbbb634544eda82ef3da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1aaf9de450193f16912fb5a31781cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a2a1aaf9de450193f16912fb5a31781cd">operator==</a> (const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a2a1aaf9de450193f16912fb5a31781cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if *this is value equal to <code>rhs</code>.  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a2a1aaf9de450193f16912fb5a31781cd">More...</a><br /></td></tr>
<tr class="separator:a2a1aaf9de450193f16912fb5a31781cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e6149b5d6a08f7abc7ba8c925aa583"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a48e6149b5d6a08f7abc7ba8c925aa583">operator!=</a> (const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a48e6149b5d6a08f7abc7ba8c925aa583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if *this is different from <code>rhs</code>.  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a48e6149b5d6a08f7abc7ba8c925aa583">More...</a><br /></td></tr>
<tr class="separator:a48e6149b5d6a08f7abc7ba8c925aa583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d79acd1184436a2763565723ae111b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d79acd1184436a2763565723ae111b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a2fa0152b0d5c3fecb751e4d166eefd7b">gather_return_type</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a8d79acd1184436a2763565723ae111b8">gather</a> (T &amp;&amp;input, <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a20854b131da254b8288d0fbd0b64be83">size_type</a> root) const</td></tr>
<tr class="memdesc:a8d79acd1184436a2763565723ae111b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers consistently sized, but otherwise arbitrary data to a MPI process <code>root</code>.  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a8d79acd1184436a2763565723ae111b8">More...</a><br /></td></tr>
<tr class="separator:a8d79acd1184436a2763565723ae111b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1d45ccd44cc295de738a4dd6f151d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef1d45ccd44cc295de738a4dd6f151d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#af380842c525736532d737f78aada76d3">all_gather_return_type</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#aef1d45ccd44cc295de738a4dd6f151d1">gather</a> (T &amp;&amp;input) const</td></tr>
<tr class="memdesc:aef1d45ccd44cc295de738a4dd6f151d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers consistently sized, but otherwise arbitrary data to each MPI process.  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#aef1d45ccd44cc295de738a4dd6f151d1">More...</a><br /></td></tr>
<tr class="separator:aef1d45ccd44cc295de738a4dd6f151d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3899ff875f40c3ccb8ab1906938373"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf3899ff875f40c3ccb8ab1906938373"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a2fa0152b0d5c3fecb751e4d166eefd7b">gather_return_type</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#aaf3899ff875f40c3ccb8ab1906938373">gatherv</a> (T &amp;&amp;input, <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a20854b131da254b8288d0fbd0b64be83">size_type</a> root) const</td></tr>
<tr class="memdesc:aaf3899ff875f40c3ccb8ab1906938373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers arbitrary data to a MPI process <code>root</code>.  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#aaf3899ff875f40c3ccb8ab1906938373">More...</a><br /></td></tr>
<tr class="separator:aaf3899ff875f40c3ccb8ab1906938373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2cc03cca61753dd086e330ea10063c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd2cc03cca61753dd086e330ea10063c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#af380842c525736532d737f78aada76d3">all_gather_return_type</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#acd2cc03cca61753dd086e330ea10063c">gatherv</a> (T &amp;&amp;input) const</td></tr>
<tr class="memdesc:acd2cc03cca61753dd086e330ea10063c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers arbitrary data to each MPI process.  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#acd2cc03cca61753dd086e330ea10063c">More...</a><br /></td></tr>
<tr class="separator:acd2cc03cca61753dd086e330ea10063c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71da9d86a76f6bb186756ed8d9517b05"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fxn &gt; </td></tr>
<tr class="memitem:a71da9d86a76f6bb186756ed8d9517b05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a878084730a152f609d894ab893309947">reduce_return_type</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a71da9d86a76f6bb186756ed8d9517b05">reduce</a> (T &amp;&amp;input, Fxn &amp;&amp;fxn, <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a20854b131da254b8288d0fbd0b64be83">size_type</a> root) const</td></tr>
<tr class="memdesc:a71da9d86a76f6bb186756ed8d9517b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces an array, and collects the result on a root process.  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a71da9d86a76f6bb186756ed8d9517b05">More...</a><br /></td></tr>
<tr class="separator:a71da9d86a76f6bb186756ed8d9517b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf42fbc6d2d5e4fadc33db78d9ef018"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fxn &gt; </td></tr>
<tr class="memitem:a8bf42fbc6d2d5e4fadc33db78d9ef018"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#aee605191b4a081c7538abfda709177b8">all_reduce_return_type</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a8bf42fbc6d2d5e4fadc33db78d9ef018">reduce</a> (T &amp;&amp;input, Fxn &amp;&amp;fxn) const</td></tr>
<tr class="memdesc:a8bf42fbc6d2d5e4fadc33db78d9ef018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces an array, and collects the result on each process.  <a href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a8bf42fbc6d2d5e4fadc33db78d9ef018">More...</a><br /></td></tr>
<tr class="separator:a8bf42fbc6d2d5e4fadc33db78d9ef018"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A little wrapper around an MPI communicator to make it more C++ friendly. </p>
<p>This class is meant to provide an object-oriented API to MPI and takes care of many of the annoying things one may need to do in order to use an arbitrary C++ object with MPI. Users of parallelzone should consider this the absolute lowest level API and should not have to ever interact with MPI directly. The guts of this class are such that they should be able to take care of every optimization which is possible without the user needing to break API. That said the underlying implementations are probably not fully optimized so if you see opportunities for optimization please do so under the hood instead of breaking API. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acfd0b7376675a7b4b7e5d43b7f357f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd0b7376675a7b4b7e5d43b7f357f3b">&#9670;&nbsp;</a></span>CommPP() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">parallelzone::mpi_helpers::CommPP::CommPP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a null communicator. </p>
<p>The instance resulting from this ctor wraps the MPI_COMM_NULL instance. The communicator has a size of 0 and the rank of the current process is MPI_PROC_NULL.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e2b3738bafcb60e3dd2f2da0be94b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2b3738bafcb60e3dd2f2da0be94b19">&#9670;&nbsp;</a></span>CommPP() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">parallelzone::mpi_helpers::CommPP::CommPP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#ac3d74cca17008c02706ab32ce0ed8374">mpi_comm_type</a>&#160;</td>
          <td class="paramname"><em>comm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a communicator which wraps <code>comm</code>. </p>
<p>MPI groups processes into communicators. This ctor will initialize *this so that it wraps the MPI communicator identified by the handle <code>comm</code>.</p>
<p>Under the hood this will call MPI_Comm_size and MPI_Comm_rank on the provided communicator and cache the results. If the user frees the communicator wrapped by *this and still tries to access state of *this bad things will happen, but I don't know any way of causing *this to own a copy of <code>comm</code> to prevent that from happening.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>The handle of the MPI communicator to initialize *this from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37d6205deb2e6dbb3d52526e4316c826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d6205deb2e6dbb3d52526e4316c826">&#9670;&nbsp;</a></span>CommPP() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parallelzone::mpi_helpers::CommPP::CommPP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html" title="A little wrapper around an MPI communicator to make it more C++ friendly.">CommPP</a> instance which is a "deep" copy of <code>other</code>. </p>
<p>This ctor initializes *this as a deep copy of <code>other</code>. In practice this means that *this will contain a copy of the MPI handle so that changing the communicator of <code>other</code> will not affect *this; however, since the MPI communicators are just handles actually modifying the underlying MPI communicator will affect *this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The communicator we are copying. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95478ed25c725a635298e86af605ac69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95478ed25c725a635298e86af605ac69">&#9670;&nbsp;</a></span>CommPP() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">parallelzone::mpi_helpers::CommPP::CommPP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html" title="A little wrapper around an MPI communicator to make it more C++ friendly.">CommPP</a> by taking ownership of the state in <code>other</code>. </p>
<p>This ctor initializes *this by taking ownership of the state in <code>other</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The object whose state is being taken. After this operation <code>other</code> is in a state analogous to default initialization.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af088c30e7b0c55af6db18ec21348b54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af088c30e7b0c55af6db18ec21348b54a">&#9670;&nbsp;</a></span>comm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#ac3d74cca17008c02706ab32ce0ed8374">CommPP::mpi_comm_type</a> parallelzone::mpi_helpers::CommPP::comm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the underlying MPI communicator. </p>
<p>*this ultimately wraps an MPI communicator. This method will return a handle to the underlying MPI communicator. If *this has is a null communicator, either because it was default initialized or initialized to a null communicator, the result will be MPI_COMM_NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>A handle to the undelrying MPI communicato or MPI_COMM_NULL if there is no underlying communicator.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>no throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef1d45ccd44cc295de738a4dd6f151d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1d45ccd44cc295de738a4dd6f151d1">&#9670;&nbsp;</a></span>gather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#af380842c525736532d737f78aada76d3">CommPP::all_gather_return_type</a>&lt; T &gt; parallelzone::mpi_helpers::CommPP::gather </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers consistently sized, but otherwise arbitrary data to each MPI process. </p>
<p>In a gather operation involving <code>N</code> processes, the data from each process will be concatenated into an <code>N</code> element array such that the <code>i</code>-th piece of data came from the process with rank <code>i</code>. It should be noted that the data sent from each process needs to be a single object, but that object can contain multiple elements. For example, <code>T == std::vector&lt;double&gt;</code> sends a single <code>std::vector</code> instance which (may) contains multiple <code>double</code> values.</p>
<p>This gather call will provide each process with a copy of the gathered data. If only one process needs a copy of the data consider the overload of <code>gather</code> which does takes a root process.</p>
<p>This method honors the type traits stated in the (TODO: Add link when the documentation is done) section.</p>
<p>This call is ultimately equivalent to calling MPI_Allgather.</p>
<dl class="section warning"><dt>Warning</dt><dd>This method is only suitable for use when the size of <code>input</code> (in bytes) is the same on all ranks. If the size is not the same on all ranks (or you can't guarantee that it is) you need to use gatherv.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The qualified type of the data to gather.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>This process's contribution to the gather operation. The size of input (in bytes) must be the same on all ranks for this method to work..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gathered data. If <code>T</code> needs to be serialized the result is a std::vector&lt;T&gt;, otherwise it's an object of type <code>T</code>. </dd></dl>

</div>
</div>
<a id="a8d79acd1184436a2763565723ae111b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d79acd1184436a2763565723ae111b8">&#9670;&nbsp;</a></span>gather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a2fa0152b0d5c3fecb751e4d166eefd7b">CommPP::gather_return_type</a>&lt; T &gt; parallelzone::mpi_helpers::CommPP::gather </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a20854b131da254b8288d0fbd0b64be83">size_type</a>&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers consistently sized, but otherwise arbitrary data to a MPI process <code>root</code>. </p>
<p>In a gather operation involving <code>N</code> processes, the data from each process will be concatenated into an <code>N</code> element array such that the <code>i</code>-th piece of data came from the process with rank <code>i</code>. It should be noted that the data sent from each process needs to be a single object, but that object can contain multiple elements. For example, <code>T == std::vector&lt;double&gt;</code> sends a single <code>std::vector</code> instance which (may) contains multiple <code>double</code> values.</p>
<p>This gather call will only collect the result on the process whose rank is <code>root</code>. All other processes send data, but do not end up with the result. To give every process a copy of the data use an "all gather" operation (the overload of <code>gather</code> which does not take a root process).</p>
<p>This method honors the type traits stated in the (TODO: Add link when the documentation is done) section.</p>
<p>This call is ultimately equivalent to calling MPI_Gather.</p>
<dl class="section warning"><dt>Warning</dt><dd>This method is only suitable for use when the size of <code>input</code> (in bytes) is the same on all ranks. If the size is not the same on all ranks (or you can't guarantee that it is) you need to use gatherv.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The qualified type of the data to gather.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>This process's contribution to the gather operation. The size of input (in bytes) must be the same on all ranks for this method to work.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>The rank of the process which will get all of the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::optional which has a value on process <code>root</code> and no value on all other processes. If <code>T</code> needs serialized the optional holds a <code>std::vector&lt;T&gt;</code>; if <code>T</code> does not need serialized the optional holds an object of type <code>T</code>. </dd></dl>

</div>
</div>
<a id="acd2cc03cca61753dd086e330ea10063c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2cc03cca61753dd086e330ea10063c">&#9670;&nbsp;</a></span>gatherv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#af380842c525736532d737f78aada76d3">CommPP::all_gather_return_type</a>&lt; T &gt; parallelzone::mpi_helpers::CommPP::gatherv </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers arbitrary data to each MPI process. </p>
<p>In a gather operation involving <code>N</code> processes, the data from each process will be concatenated into an <code>N</code> element array such that the <code>i</code>-th piece of data came from the process with rank <code>i</code>. It should be noted that the data sent from each process needs to be a single object, but that object can contain multiple elements. For example, <code>T == std::vector&lt;double&gt;</code> sends a single <code>std::vector</code> instance which (may) contains multiple <code>double</code> values.</p>
<p>This gather call will provide each process with a copy of the gathered data. If only one process needs a copy of the data consider the overload of <code>gather</code> which does takes a root process. Unlike gather, gatherv allows the size of <code>input</code> (in bytes) to be different on different ranks. This has additional communication overhead relative to the normal gather call, so use gather if you can guarantee that your data's size is consistent.</p>
<p>This method honors the type traits stated in the (TODO: Add link when the documentation is done) section.</p>
<p>This call is ultimately equivalent to calling MPI_Allgatherv.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The qualified type of the data to gather.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>This process's contribution to the gather operation. The size of input (in bytes) can vary from rank to rank.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gathered data. If <code>T</code> needs to be serialized the result is a std::vector&lt;T&gt;, otherwise it's an object of type <code>T</code>. </dd></dl>

</div>
</div>
<a id="aaf3899ff875f40c3ccb8ab1906938373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3899ff875f40c3ccb8ab1906938373">&#9670;&nbsp;</a></span>gatherv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a2fa0152b0d5c3fecb751e4d166eefd7b">CommPP::gather_return_type</a>&lt; T &gt; parallelzone::mpi_helpers::CommPP::gatherv </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a20854b131da254b8288d0fbd0b64be83">size_type</a>&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers arbitrary data to a MPI process <code>root</code>. </p>
<p>In a gather operation involving <code>N</code> processes, the data from each process will be concatenated into an <code>N</code> element array such that the <code>i</code>-th piece of data came from the process with rank <code>i</code>. It should be noted that the data sent from each process needs to be a single object, but that object can contain multiple elements. For example, <code>T == std::vector&lt;double&gt;</code> sends a single <code>std::vector</code> instance which (may) contains multiple <code>double</code> values.</p>
<p>This gather call will only collect the result on the process whose rank is <code>root</code>. All other processes send data, but do not end up with the result. To give every process a copy of the data use an "all gatherv" operation (the overload of <code>gatherv</code> which does not take a root process). Unlike gather, gatherv allows the size of <code>input</code> (in bytes) to be different on different ranks. This has additional communication overhead relative to the normal gather call, so use gather if you can guarantee that your data's size is consistent.</p>
<p>This method honors the type traits stated in the (TODO: Add link when the documentation is done) section.</p>
<p>This call is ultimately equivalent to calling MPI_Gatherv.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The qualified type of the data to gather.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>This process's contribution to the gather operation.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>The rank of the process which will get all of the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::optional which has a value on process <code>root</code> and no value on all other processes. If <code>T</code> needs serialized the optional holds a <code>std::vector&lt;T&gt;</code>; if <code>T</code> does not need serialized the optional holds an object of type <code>T</code>. </dd></dl>

</div>
</div>
<a id="ad1a8b81c9b466b24e55575c9b01863cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a8b81c9b466b24e55575c9b01863cb">&#9670;&nbsp;</a></span>me()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a20854b131da254b8288d0fbd0b64be83">CommPP::size_type</a> parallelzone::mpi_helpers::CommPP::me </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank of the current process. </p>
<p>In MPI processes are grouped into communicators. Each process in the communicator has a unique ID ranging from 0 to the size of the communicator. This method is used to retrieve the rank of the current process. If this communicator is null, either because it was default initialized or because it was set to null, then the result will be MPI_PROC_NULL.</p>
<p>Calling this method is logically the same as calling MPI_Comm_rank. The actual call is only done during construction and the result is cached in *this.</p>
<dl class="section return"><dt>Returns</dt><dd>The ID of the current process according to the communicator wrapped by *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48e6149b5d6a08f7abc7ba8c925aa583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e6149b5d6a08f7abc7ba8c925aa583">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool parallelzone::mpi_helpers::CommPP::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if *this is different from <code>rhs</code>. </p>
<p>This method simply negates value equality. See the description of operator== for more information on how value equality is determined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The object being compared to *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if *this is value equal to <code>rhs</code> and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4f8f1084fb3fd365af2bb3990d2803a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f8f1084fb3fd365af2bb3990d2803a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp; parallelzone::mpi_helpers::CommPP::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfers the state in <code>other</code> to *this. </p>
<p>This operation will move the state in <code>other</code> to *this. In the process the current state of *this will be released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The object whose state is being taken. After this operation <code>other</code> is in a state analogous to default initialization.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this after replacing its state with the state in <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe6b12af2ab5597be387126a32d9d7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6b12af2ab5597be387126a32d9d7d1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp; parallelzone::mpi_helpers::CommPP::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes *this a deep copy of <code>other</code>. </p>
<p>This operation will replace the contents of *this (freeing the current state up in the process) with a deep copy of the state in <code>other</code>. See the copy ctor for details pertaining to what a deep copy entails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The object to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this after replacing its state with a copy of <code>rhs</code>. </dd></dl>

</div>
</div>
<a id="a2a1aaf9de450193f16912fb5a31781cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1aaf9de450193f16912fb5a31781cd">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool parallelzone::mpi_helpers::CommPP::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if *this is value equal to <code>rhs</code>. </p>
<p>*this is value equal to <code>rhs</code> if both *this and <code>rhs</code> are null communicators, either by being default constructed or by being set to MPI_COMM_NULL, or if both *this and <code>rhs</code> wrap handles to the same MPI communicator (as determined by MPI_Comm_compare).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The object being compared to *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if *this is value equal to <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bf42fbc6d2d5e4fadc33db78d9ef018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf42fbc6d2d5e4fadc33db78d9ef018">&#9670;&nbsp;</a></span>reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Fxn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#aee605191b4a081c7538abfda709177b8">CommPP::all_reduce_return_type</a>&lt; T &gt; parallelzone::mpi_helpers::CommPP::reduce </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fxn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fxn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces an array, and collects the result on each process. </p>
<p>In a reduction operation involving <img class="formulaInl" alt="$P$" src="form_0.png"/> processes, process <img class="formulaInl" alt="$i$" src="form_1.png"/> starts with an <img class="formulaInl" alt="$N$" src="form_2.png"/>-element array <img class="formulaInl" alt="$A_i$" src="form_3.png"/>. The result, <img class="formulaInl" alt="$R$" src="form_4.png"/>, is also an <img class="formulaInl" alt="$N$" src="form_2.png"/>-element array. The <img class="formulaInl" alt="$j$" src="form_5.png"/>-th element or <img class="formulaInl" alt="$R$" src="form_4.png"/> is given by:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ R[j] = \bigotimes_{i=1}^P A_i[j], \]" src="form_6.png"/>
</p>
<p>where <img class="formulaInl" alt="$\bigotimes$" src="form_7.png"/> is a stand in for whatever reduction operation was specified, <em>e.g.</em>, if the reduction operation was summation, <img class="formulaInl" alt="$R$" src="form_4.png"/> is given by:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ R[j] = \sum_{i=1}^P A_i[j], \]" src="form_8.png"/>
</p>
<p>Note that the reduction occurs across the process index and NOT across the element index. If the goal is to, for example, sum all of the <img class="formulaInl" alt="$N$" src="form_2.png"/> elements in the <img class="formulaInl" alt="$P$" src="form_0.png"/> arrays to get a single element, then one must either sum the <img class="formulaInl" alt="$N$" src="form_2.png"/> elements together prior to the reduction or one must sum the resulting <img class="formulaInl" alt="$N$" src="form_2.png"/> elements together after the reduction.</p>
<p>This overload of reduce will collect the result to every process. See the other overload of reduce if you only need the result on one process.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The qualified type of the array being reduced. <code>T</code> is assumed to possibly be a cv-qualified and/or reference to an object of type U. U is assumed to be a contiguous container whose elements map to a known MPI data type. If the elements are not a known MPI data type, or if <code>U</code> needs to be serialized, a static assert will be tripped.</td></tr>
    <tr><td class="paramname">Fxn</td><td>The qualified type of the reduction functor. <code>Fxn</code> is assumed to possibly be a cv-qualified and/or reference to a functor. The functor is assumed to be an instantiation of a functor in the C++ standard library that maps to a known MPI operation, <em>e.g.</em>, std::plus. A static assert will be raised if the functor does not map to a known MPI operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The array we are reducing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fxn</td><td>The functor to use for the reduction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On all processes the result will be an array whose elements are obtained by applying <code>fxn</code> across the process index (see description). </dd></dl>

</div>
</div>
<a id="a71da9d86a76f6bb186756ed8d9517b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71da9d86a76f6bb186756ed8d9517b05">&#9670;&nbsp;</a></span>reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Fxn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a878084730a152f609d894ab893309947">CommPP::reduce_return_type</a>&lt; T &gt; parallelzone::mpi_helpers::CommPP::reduce </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fxn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a20854b131da254b8288d0fbd0b64be83">size_type</a>&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces an array, and collects the result on a root process. </p>
<p>In a reduction operation involving <img class="formulaInl" alt="$P$" src="form_0.png"/> processes, process <img class="formulaInl" alt="$i$" src="form_1.png"/> starts with an <img class="formulaInl" alt="$N$" src="form_2.png"/>-element array <img class="formulaInl" alt="$A_i$" src="form_3.png"/>. The result, <img class="formulaInl" alt="$R$" src="form_4.png"/>, is also an <img class="formulaInl" alt="$N$" src="form_2.png"/>-element array. The <img class="formulaInl" alt="$j$" src="form_5.png"/>-th element or <img class="formulaInl" alt="$R$" src="form_4.png"/> is given by:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ R[j] = \bigotimes_{i=1}^P A_i[j], \]" src="form_6.png"/>
</p>
<p>where <img class="formulaInl" alt="$\bigotimes$" src="form_7.png"/> is a stand in for whatever reduction operation was specified, <em>e.g.</em>, if the reduction operation was summation, <img class="formulaInl" alt="$R$" src="form_4.png"/> is given by:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ R[j] = \sum_{i=1}^P A_i[j], \]" src="form_8.png"/>
</p>
<p>Note that the reduction occurs across the process index and NOT across the element index. If the goal is to, for example, sum all of the <img class="formulaInl" alt="$N$" src="form_2.png"/> elements in the <img class="formulaInl" alt="$P$" src="form_0.png"/> arrays to get a single element, then one must either sum the <img class="formulaInl" alt="$N$" src="form_2.png"/> elements together prior to the reduction or one must sum the resulting <img class="formulaInl" alt="$N$" src="form_2.png"/> elements together after the reduction.</p>
<p>This overload of reduce will only collect the result to process <code>root</code>. See the other overload of reduce if you want all processes to have a copy.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The qualified type of the array being reduced. <code>T</code> is assumed to possibly be a cv-qualified and/or reference to an object of type U. U is assumed to be a contiguous container whose elements map to a known MPI data type. If the elements are not a known MPI data type, or if <code>U</code> needs to be serialized, a static assert will be tripped.</td></tr>
    <tr><td class="paramname">Fxn</td><td>The qualified type of the reduction functor. <code>Fxn</code> is assumed to possibly be a cv-qualified and/or reference to a functor. The functor is assumed to be an instantiation of a functor in the C++ standard library that maps to a known MPI operation, <em>e.g.</em>, std::plus. A static assert will be raised if the functor does not map to a known MPI operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The array we are reducing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fxn</td><td>The functor to use for the reduction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>The zero-based rank of the process to collect the result on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On the root process the result will be a std::optional which holds an array whose elements are obtained by applying <code>fxn</code> across the process index (see description). On all other processes the resulting std::optional will be empty. </dd></dl>

</div>
</div>
<a id="a1145df087b6306bab858288116cdc30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1145df087b6306bab858288116cdc30f">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#a20854b131da254b8288d0fbd0b64be83">CommPP::size_type</a> parallelzone::mpi_helpers::CommPP::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of ranks manged by <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html#af088c30e7b0c55af6db18ec21348b54a" title="Returns a handle to the underlying MPI communicator.">comm()</a> </p>
<p>In MPI, processes are grouped into communicators. This method is used to determine how many processes are associated with the communicator held by *this. If *this is a null communicator, either because it was default initialized or because it was initialized to a null communicator, the size will be 0.</p>
<p>Calling this method is logically the same as calling MPI_Comm_size. The actual call is only done during construction and the result is cached in *this.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of processes associated with the wrapped MPI communicator.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a623ba9a8840dbbb634544eda82ef3da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623ba9a8840dbbb634544eda82ef3da2">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void parallelzone::mpi_helpers::CommPP::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html">CommPP</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the state in *this with that in <code>other</code>. </p>
<p>This method is used to exchange the stat of *this with the state in another <a class="el" href="classparallelzone_1_1mpi__helpers_1_1CommPP.html" title="A little wrapper around an MPI communicator to make it more C++ friendly.">CommPP</a> object. After this operation *this will contain the state which was originally in <code>other</code> and <code>other</code> will contain the state which was originally in *this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The object whose state will be exchanged with *this. After the operation <code>other</code> will contain the state which was in *this before the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/parallelzone/mpi_helpers/commpp/<a class="el" href="commpp_8hpp_source.html">commpp.hpp</a></li>
<li>include/parallelzone/mpi_helpers/commpp/<a class="el" href="commpp_8ipp.html">commpp.ipp</a></li>
<li>src/parallelzone/mpi_helpers/commpp/commpp.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
